#include "lgamma.h"

#include "core/logging.h"
#include "kernels/debug.h"
#include "kernels/kernel.h"
#include "kernels/unary_op/unary_op_3pipeline.h"
#include "kernels/unary_op/unary_op_5pipeline.h"

#define LGAMMA_NRAM_USED (MAX_NRAM_SIZE - 5*1024)
#define LGAMMA_SRAM_USED (CORE_DIM * LGAMMA_NRAM_USED)

__nram__ char nram_buffer[LGAMMA_NRAM_USED];

const int inf_float_value = 0x7f800000;
const int nan_float_mask = inf_float_value | 0x7fffff;
const float log_e_2 = 0.69314718055994530941723212145818; // ln(x) = log(x) * log_e_2

#define AUX_N 5
#define fs0 aux_array[0]
#define fs1 aux_array[1]
#define fs2 aux_array[2]
#define fs4 aux_array[3]
#define fa5 aux_array[4]
#define fa0 aux_array[5]

// macro for vector multiplexer 2 to 1, sel is 0/1 vector
// dst = a*sel + !sel*b
// a can overlap with dst
// float 1: [0 01111111 00000000000000000000000] >> 29 -> int 1
#define __bang_mux2(dst, a, b, sel, sz) __bang_srl((unsigned int*)sel, (unsigned int*)sel, 29, sz); \
                                        __bang_mul_scalar((int*)sel, (int*)sel, -1, sz); \
                                        __bang_band((char*)dst, (char*)a,   (char*)sel, sz*sizeof(float)); \
                                        __bang_bnot((char*)sel, (char*)sel, sz*sizeof(float)); \
                                        __bang_band((char*)sel, (char*)b,   (char*)sel, sz*sizeof(float)); \
                                        __bang_add(dst, dst, sel, sz)

#define __bang_isfinite(dst, src, sz) __bang_band_scalar(dst, src, (float)inf_float_value, sz); \
                                      __bang_ne_scalar(dst, dst, (float)inf_float_value, sz)

#define __bang_isinf(dst, src, sz) __bang_band_scalar(dst, src, (float)nan_float_mask, sz); \
                                   __bang_eq_scalar(dst, dst, (float)inf_float_value, sz)

#define __bang_loghp(dst, src, sz) __bang_log(dst, src, sz); \
                                   __bang_mul_scalar(dst, dst, log_e_2, sz);

template <typename T>
__mlu_global__ void MLUBlockKernelLgamma(T *x, T *y, int total) {
  static const float log_pi = 1.144730;
  static const float log_sqrt_two_pi = 0.918939;
  static const float kLanczosGamma = 7; 
  static const float kBaseLanczosCoeff = 0.99999999999980993227684700473478;
  static const float log_lanczos_gamma_plus_one_half = 2.014903;

  int core_n = total / taskDim;   // size of vector that each core computing 
  int rem_n = total % taskDim;    
  if (taskId <= rem_n) {
    core_n += 1;
    x += core_n*taskId;
    y += core_n*taskId;
  } else {
    x += (core_n + 1) * rem_n + core_n * (taskId - rem_n);
    y += (core_n + 1) * rem_n + core_n * (taskId - rem_n);
  }

  float* aux_array[AUX_N];
  int arr_size = FLOOR_ALIGN(LGAMMA_NRAM_USED / sizeof(float) / AUX_N, UNARY_ALIGN_NUM);
  int pos = 0;
  for (size_t i = 0; i < AUX_N; i++) {
    aux_array[i] = (float*)nram_buffer + pos;
    pos += arr_size;
  }

  for (size_t i = 0; i < core_n; i += arr_size) {
    int num_deal = i + arr_size > core_n ? core_n - i : arr_size;

    // using fs1 -> input
    if (sizeof(T) == sizeof(float)) {
      __memcpy(fs1, x + i, num_deal*sizeof(float), GDRAM2NRAM);  
    } else if (sizeof(T) == sizeof(half)) {  // half
      __memcpy(fs0, x + i, num_deal*sizeof(half), GDRAM2NRAM);  
      __bang_half2float(fs1, (half *)fs0, num_deal);
    }

    /**
     * bool need_to_reflect = (input < 0.5); 
     */
    __bang_lt_scalar(fa5, fs1, 0.5, num_deal);

    /**
     * float input_after_reflect = need_to_reflect ? -input : input - 1;  // aka z
     */
    // using fs0 -> input_after_reflect
    __bang_mul_scalar(fs0, fs1, -1, num_deal);
    __bang_add_scalar(fs2, fs1, -1, num_deal);
    __bang_mux2(fs0, fs0, fs2, fa5, num_deal);
    // __bang_printf("ckpt2, %lf\n", *(fs0));

    /**
     * float sum = kBaseLanczosCoeff;  // aka x
     * for (int i = 0, end = 8; i < end; ++i) {
     *   float lanczos_coefficient = kLanczosCoefficients[i];
     *   sum += lanczos_coefficient / (input_after_reflect + i + 1);
     * }
     */
    // do loop flatten, using fs2 -> sum
    __bang_write_value(fs2, num_deal, (float)kBaseLanczosCoeff);
    __bang_write_value(fa5, num_deal, (float)676.520368121885098844);
    __bang_add_scalar(fs4, fs0, 1, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)-1259.139216722402807136);
    __bang_add_scalar(fs4, fs0, 2, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)771.323428777653134603);
    __bang_add_scalar(fs4, fs0, 3, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)-176.615029162140587005);
    __bang_add_scalar(fs4, fs0, 4, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)12.507343278686905208);
    __bang_add_scalar(fs4, fs0, 5, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)-0.138571095265720118);
    __bang_add_scalar(fs4, fs0, 6, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)0.000009984369578020);
    __bang_add_scalar(fs4, fs0, 7, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);
    __bang_write_value(fa5, num_deal, (float)0.000000150563273515);
    __bang_add_scalar(fs4, fs0, 8, num_deal);
    __mluop_div(fs4, fa5, fs4, (float *)0, 0, num_deal);    // __bang_div(fs4, fa5, fs4, num_deal);
    __bang_add(fs2, fs2, fs4, num_deal);

    /**
     * float gamma_plus_onehalf_plus_z = kLanczosGamma + 0.5 + input_after_reflect;  // aka t
     */
    // using fs4 -> gamma_plus_onehalf_plus_z
    __bang_add_scalar(fs4, fs0, kLanczosGamma+0.5, num_deal);

    /** 
     * float log_t = log_lanczos_gamma_plus_one_half + log1pf(input_after_reflect / (kLanczosGamma + 0.5));
     */
    // using fa5 -> log_t
    __bang_write_value(fa5, num_deal, (float)(kLanczosGamma+0.5));
    __mluop_div(fa5, fs0, fa5, (float *)0, 0, num_deal);
    __bang_add_scalar(fa5, fa5, 1, num_deal);
    __bang_loghp(fa5, fa5, num_deal);
    __bang_add_scalar(fa5, fa5, log_lanczos_gamma_plus_one_half, num_deal);

    /**
     * float log_y = log_sqrt_two_pi + (input_after_reflect + 0.5 - gamma_plus_onehalf_plus_z / log_t) * log_t + log(sum);
     *  ---->
     *        log_y = log_sqrt_two_pi + (input_after_reflect + 0.5) * log_t - gamma_plus_onehalf_plus_z + log(sum)
    */
    // using fs0 -> log_y
    __bang_loghp(fs2, fs2, num_deal);
    __bang_add_scalar(fs0, fs0, 0.5, num_deal);
    __bang_mul(fs0, fs0, fa5, num_deal);
    __bang_add_scalar(fs0, fs0, log_sqrt_two_pi, num_deal);
    __bang_sub(fs0, fs0, fs4, num_deal);
    __bang_add(fs0, fs0, fs2, num_deal);

    /**
     * float abs_input = fabs(input);
     * float abs_frac_input = abs_input - floorf(abs_input);
    */
    // using fa5 -> abs_frac_input
    __bang_abs(fs2, fs1, num_deal);
    __bang_floor(fs4, fs2, num_deal);
    __bang_sub(fa5, fs2, fs4, num_deal);

    /**
     * float reduced_frac_input = (abs_frac_input > 0.5) ? 1 - abs_frac_input : abs_frac_input;
    */
    // using fs4 -> reduced_frac_input
    __bang_gt_scalar(fs2, fa5, 0.5, num_deal);
    __bang_mul_scalar(fs4, fa5, -1, num_deal);
    __bang_add_scalar(fs4, fs4, 1, num_deal);
    __bang_mux2(fs4, fs4, fa5, fs2, num_deal);

    /**
     * float reflection_denom = log(sinf(M_PI * reduced_frac_input));
    */
    // using fs2 -> reflection_denom
    __bang_mul_scalar(fs2, fs4, M_PI, num_deal);
    __bang_sin(fs2, fs2, num_deal);               // active sin ?
    __bang_loghp(fs2, fs2, num_deal);               // active log ?
    
    /**
     * float reflection = std::isfinite(reflection_denom) ? log_pi - reflection_denom - log_y : -reflection_denom;
    */
    // using fs4 -> reflection
    __bang_write_zero(fa5, num_deal);
    __bang_sub(fs2, fa5, fs2, num_deal);
    __bang_isfinite(fa5, fs2, num_deal);
    __bang_sub(fs4, fs2, fs0, num_deal);
    __bang_add_scalar(fs4, fs4, log_pi, num_deal);
    __bang_mux2(fs4, fs4, fs2, fa5, num_deal);


    /**
     * float result = need_to_reflect ? reflection : log_y;
    */
    // using fs2 -> result
    __bang_lt_scalar(fa5, fs1, 0.5, num_deal);
    __bang_mux2(fs2, fs4, fs0, fa5, num_deal);

    /**
     * return isinf(input) ? INFINITY : result;
    */ 
    __bang_isinf(fa5, fs2, num_deal);
    __bang_write_value(fs4, num_deal, (float)(inf_float_value));
    __bang_mux2(fs1, fs4, fs2, fa5, num_deal);


    if (sizeof(T) == sizeof(float)) {
      __memcpy(y + i, fs1, num_deal*sizeof(float), NRAM2GDRAM);  
    } else if (sizeof(T) == sizeof(half)) {  // half
      __mluop_float2half((half *)fs1, fs1, num_deal);
      __memcpy(y + i, fs1, num_deal*sizeof(half), NRAM2GDRAM);  
    }
  } 
}


mluOpStatus_t MLUOP_WIN_API
KernelLgamma(const cnrtDim3_t k_dim, const cnrtFunctionType_t k_type,
                        const cnrtQueue_t queue, const mluOpDataType_t d_type,
                        const void *x, void *y, const int32_t num) {
  if (d_type == MLUOP_DTYPE_FLOAT) {
    KERNEL_CHECK(
        MLUBlockKernelLgamma<<<k_dim, k_type, queue>>>((float*)x, (float*)y, num);
    );
  } else { // d_type == MLUOP_DTYPE_HALF
    KERNEL_CHECK(
        MLUBlockKernelLgamma<<<k_dim, k_type, queue>>>((half*)x, (half*)y, num);
    );
  }
  return MLUOP_STATUS_SUCCESS;
}